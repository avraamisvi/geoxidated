use std::{error::Error, fmt::Display};
use sqlx::{postgres::PgRow, Row};
use serde_json::{Value, Map};
use crate::model::{geometry::{Geometry, Point}, value::ObjectValue, feature_collection::FeatureCollection, feature::Feature};

//this module can be divided in two, parse from db and parse from serde

#[derive(Debug)]
pub struct ParseError {
    pub message: String
}

impl Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Error when parsing {}", self.message)
    }
}

impl Error for ParseError {}

impl From<serde_json::Error> for ParseError {
    fn from(value: serde_json::Error) -> Self {
        ParseError{message: value.to_string()}
    }
}

pub fn parse_feature_collection(row: &PgRow) -> Result<FeatureCollection, ParseError> {

    let id: i64 = row.try_get(0).unwrap_or(0);
    let label: String = row.try_get(1).unwrap_or("".to_string());

    Ok(FeatureCollection::new(id, label, vec![]))
}

pub fn parse_feature(row: PgRow) -> Result<Feature, ParseError> {

    let id: i64 = row.try_get(0).unwrap_or(0);
    let properties: String = row.try_get(1).unwrap_or("".to_string());
    let geometry: String = row.try_get(2).unwrap_or("".to_string());

    let geom_value: Value = serde_json::from_str(&geometry)?;

    Ok(Feature::new(id, parse_geometry(&geom_value), parse_properties(properties)?))
}

pub fn parse_geometry(geom: &Value) -> Geometry {
    if geom["type"].as_str().unwrap().to_lowercase() == "point" {
        let points = geom["coordinates"].as_array().unwrap();
        Geometry::from(Point::new(points[0].as_f64().unwrap(), points[1].as_f64().unwrap()))
    } else {
        unimplemented!()
    }
}

pub fn parse_properties(properties: String) -> Result<ObjectValue, ParseError> {
    let mapped_values: Map<String, Value> = serde_json::from_str(&properties)?;
    Ok(ObjectValue::from(&mapped_values))
}
